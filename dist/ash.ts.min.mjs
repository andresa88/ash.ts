class ListenerNode{constructor(){this.previous=null,this.next=null,this.listener=null,this.once=!1}}class ListenerNodePool{constructor(){this.tail=null,this.cacheTail=null}get(){if(this.tail){const t=this.tail;return this.tail=this.tail.previous,t.previous=null,t}return new ListenerNode}dispose(t){t.listener=null,t.once=!1,t.next=null,t.previous=this.tail,this.tail=t}cache(t){t.listener=null,t.previous=this.cacheTail,this.cacheTail=t}releaseCache(){for(;this.cacheTail;){const t=this.cacheTail;this.cacheTail=t.previous,t.next=null,t.previous=this.tail,this.tail=t}}}class SignalBase{constructor(){this.head=null,this.tail=null,this.toAddHead=null,this.toAddTail=null,this.dispatching=!1,this.pNumListeners=0,this.nodes=new Map,this.listenerNodePool=new ListenerNodePool}startDispatch(){this.dispatching=!0}endDispatch(){this.dispatching=!1,this.toAddHead&&(this.head?(this.tail.next=this.toAddHead,this.toAddHead.previous=this.tail,this.tail=this.toAddTail):(this.head=this.toAddHead,this.tail=this.toAddTail),this.toAddHead=null,this.toAddTail=null),this.listenerNodePool.releaseCache()}get numListeners(){return this.pNumListeners}add(t){if(this.nodes.has(t))return;const e=this.listenerNodePool.get();e.listener=t,this.nodes.set(t,e),this.addNode(e)}addOnce(t){if(this.nodes.has(t))return;const e=this.listenerNodePool.get();e.listener=t,e.once=!0,this.nodes.set(t,e),this.addNode(e)}addNode(t){this.dispatching?this.toAddHead?(this.toAddTail.next=t,t.previous=this.toAddTail,this.toAddTail=t):this.toAddHead=this.toAddTail=t:this.head?(this.tail.next=t,t.previous=this.tail,this.tail=t):this.head=this.tail=t,this.pNumListeners+=1}remove(t){const e=this.nodes.get(t)||null;e&&(this.head===e&&(this.head=this.head.next),this.tail===e&&(this.tail=this.tail.previous),this.toAddHead===e&&(this.toAddHead=this.toAddHead.next),this.toAddTail===e&&(this.toAddTail=this.toAddTail.previous),e.previous&&(e.previous.next=e.next),e.next&&(e.next.previous=e.previous),this.nodes.delete(t),this.dispatching?this.listenerNodePool.cache(e):this.listenerNodePool.dispose(e),this.pNumListeners-=1)}removeAll(){for(;this.head;){const t=this.head;this.head=this.head.next,this.nodes.delete(t.listener),this.listenerNodePool.dispose(t)}this.tail=null,this.toAddHead=null,this.toAddTail=null,this.pNumListeners=0}}class Signal0 extends SignalBase{dispatch(){let t;for(this.startDispatch(),t=this.head;t;t=t.next)t.listener.call(t),t.once&&this.remove(t.listener);this.endDispatch()}}class Signal1 extends SignalBase{dispatch(t){let e;for(this.startDispatch(),e=this.head;e;e=e.next)e.listener.call(e,t),e.once&&this.remove(e.listener);this.endDispatch()}}class Signal2 extends SignalBase{dispatch(t,e){let i;for(this.startDispatch(),i=this.head;i;i=i.next)i.listener.call(i,t,e),i.once&&this.remove(i.listener);this.endDispatch()}}class Signal3 extends SignalBase{dispatch(t,e,i){let s;for(this.startDispatch(),s=this.head;s;s=s.next)s.listener.call(s,t,e,i),s.once&&this.remove(s.listener);this.endDispatch()}}class NodeList{constructor(){this.head=null,this.tail=null,this.nodeAdded=new Signal1,this.nodeRemoved=new Signal1}add(t){this.head?(this.tail.next=t,t.previous=this.tail,t.next=null,this.tail=t):(this.head=this.tail=t,t.next=t.previous=null),this.nodeAdded.dispatch(t)}remove(t){this.head===t&&(this.head=this.head.next),this.tail===t&&(this.tail=this.tail.previous),t.previous&&(t.previous.next=t.next),t.next&&(t.next.previous=t.previous),this.nodeRemoved.dispatch(t)}removeAll(){for(;this.head;){const t=this.head;this.head=t.next,t.previous=null,t.next=null,this.nodeRemoved.dispatch(t)}this.tail=null}get empty(){return null==this.head}swap(t,e){if(t.previous===e)t.previous=e.previous,e.previous=t,e.next=t.next,t.next=e;else if(e.previous===t)e.previous=t.previous,t.previous=e,t.next=e.next,e.next=t;else{let i=t.previous;t.previous=e.previous,e.previous=i,i=t.next,t.next=e.next,e.next=i}this.head===t?this.head=e:this.head===e&&(this.head=t),this.tail===t?this.tail=e:this.tail===e&&(this.tail=t),t.previous&&(t.previous.next=t),e.previous&&(e.previous.next=e),t.next&&(t.next.previous=t),e.next&&(e.next.previous=e)}insertionSort(t){if(this.head===this.tail)return;let e=this.head.next;for(let i=e;i;i=e){let s;for(e=i.next,s=i.previous;s;s=s.previous)if(t(i,s)>=0){i!==s.next&&(this.tail===i&&(this.tail=i.previous),i.previous.next=i.next,i.next&&(i.next.previous=i.previous),i.next=s.next,i.previous=s,i.next.previous=i,s.next=i);break}s||(this.tail===i&&(this.tail=i.previous),i.previous.next=i.next,i.next&&(i.next.previous=i.previous),i.next=this.head,this.head.previous=i,i.previous=null,this.head=i)}}mergeSort(t){if(this.head===this.tail)return;const e=[];let i,s=this.head;for(;s;){for(i=s;i.next&&t(i,i.next)<=0;)i=i.next;const n=i.next;s.previous=i.next=null,e[e.length]=s,s=n}for(;e.length>1;)e.push(this.merge(e.shift(),e.shift(),t));for(this.tail=this.head=e[0];this.tail.next;)this.tail=this.tail.next}merge(t,e,i){let s,n;for(i(t,e)<=0?(n=s=t,t=t.next):(n=s=e,e=e.next);t&&e;)i(t,e)<=0?(s.next=t,t.previous=s,s=t,t=t.next):(s.next=e,e.previous=s,s=e,e=e.next);return t?(s.next=t,t.previous=s):(s.next=e,e.previous=s),n}}class NodePool{constructor(t,e){this.tail=null,this.cacheTail=null,this.nodeClass=t,this.components=e}get(){if(this.tail){const t=this.tail;return this.tail=this.tail.previous,t.previous=null,t}return new this.nodeClass}dispose(t){for(const e of this.components.values())t[e]=null;t.entity=null,t.next=null,t.previous=this.tail,this.tail=t}cache(t){t.previous=this.cacheTail,this.cacheTail=t}releaseCache(){for(;this.cacheTail;){const t=this.cacheTail;this.cacheTail=t.previous,this.dispose(t)}}}const ashProp="__ash_types__";class ComponentMatchingFamily{constructor(t,e){this.releaseNodePoolCache=(()=>{this.engine.updateComplete.remove(this.releaseNodePoolCache),this.nodePool.releaseCache()}),this.nodeClass=t,this.engine=e,this.init()}init(){this.nodes=new NodeList,this.entities=new Map,this.components=new Map,this.nodePool=new NodePool(this.nodeClass,this.components);const t=this.nodePool.get();this.nodePool.dispose(t);const e=t.constructor[ashProp];for(const[t,i]of e)this.components.set(i,t)}get nodeList(){return this.nodes}newEntity(t){this.addIfMatch(t)}componentAddedToEntity(t,e){this.addIfMatch(t)}componentRemovedFromEntity(t,e){this.components.has(e)&&this.removeIfMatch(t)}removeEntity(t){this.removeIfMatch(t)}addIfMatch(t){if(!this.entities.has(t)){for(const e of this.components.keys())if(!t.has(e))return;const e=this.nodePool.get();e.entity=t;for(const i of this.components.keys())e[this.components.get(i)]=t.get(i);this.entities.set(t,e),this.nodes.add(e)}}removeIfMatch(t){if(this.entities.has(t)){const e=this.entities.get(t);this.entities.delete(t),this.nodes.remove(e),this.engine.updating?(this.nodePool.cache(e),this.engine.updateComplete.add(this.releaseNodePoolCache)):this.nodePool.dispose(e)}}cleanUp(){for(let t=this.nodes.head;t;t=t.next)this.entities.delete(t.entity);this.nodes.removeAll()}}function keep(t){return(e,i)=>{const s=e.constructor;let n;s.hasOwnProperty(ashProp)?n=s[ashProp]:(n=new Map,Object.defineProperty(s,ashProp,{enumerable:!0,get:()=>n})),n.set(i,t)}}class EntityList{constructor(){this.head=null,this.tail=null}add(t){this.head?(this.tail.next=t,t.previous=this.tail,t.next=null,this.tail=t):(this.head=this.tail=t,t.next=t.previous=null)}remove(t){this.head===t&&(this.head=this.head.next),this.tail===t&&(this.tail=this.tail.previous),t.previous&&(t.previous.next=t.next),t.next&&(t.next.previous=t.previous)}removeAll(){for(;this.head;){const t=this.head;this.head=this.head.next,t.previous=null,t.next=null}this.tail=null}}class SystemList{constructor(){this.head=null,this.tail=null}add(t){if(this.head){let e;for(e=this.tail;e&&!(e.priority<=t.priority);e=e.previous);e===this.tail?(this.tail.next=t,t.previous=this.tail,t.next=null,this.tail=t):e?(t.next=e.next,t.previous=e,e.next.previous=t,e.next=t):(t.next=this.head,t.previous=null,this.head.previous=t,this.head=t)}else this.head=this.tail=t,t.next=t.previous=null}remove(t){this.head===t&&(this.head=this.head.next),this.tail===t&&(this.tail=this.tail.previous),t.previous&&(t.previous.next=t.next),t.next&&(t.next.previous=t.previous)}removeAll(){for(;this.head;){const t=this.head;this.head=this.head.next,t.previous=null,t.next=null}this.tail=null}get(t){for(let e=this.head;e;e=e.next)if(e instanceof t)return e;return null}}class Engine{constructor(){this.updating=!1,this.familyClass=ComponentMatchingFamily,this.entityNameChanged=((t,e)=>{this.entityNames.get(e)===t&&(this.entityNames.delete(e),this.entityNames.set(t.name,t))}),this.componentAdded=((t,e)=>{for(const i of this.families.values())i.componentAddedToEntity(t,e)}),this.componentRemoved=((t,e)=>{for(const i of this.families.values())i.componentRemovedFromEntity(t,e)}),this.entityList=new EntityList,this.entityNames=new Map,this.systemList=new SystemList,this.families=new Map,this.updateComplete=new Signal0}addEntity(t){if(this.entityNames.has(t.name))throw new Error("The entity name "+t.name+" is already in use by another entity.");this.entityList.add(t),this.entityNames.set(t.name,t),t.componentAdded.add(this.componentAdded),t.componentRemoved.add(this.componentRemoved),t.nameChanged.add(this.entityNameChanged);for(const e of this.families.values())e.newEntity(t)}removeEntity(t){t.componentAdded.remove(this.componentAdded),t.componentRemoved.remove(this.componentRemoved),t.nameChanged.remove(this.entityNameChanged);for(const e of this.families.values())e.removeEntity(t);this.entityNames.delete(t.name),this.entityList.remove(t)}getEntityByName(t){return this.entityNames.get(t)||null}removeAllEntities(){for(;this.entityList.head;)this.removeEntity(this.entityList.head)}get entities(){const t=[];for(let e=this.entityList.head;e;e=e.next)t[t.length]=e;return t}getNodeList(t){if(this.families.has(t))return this.families.get(t).nodeList;const e=new this.familyClass(t,this);this.families.set(t,e);for(let t=this.entityList.head;t;t=t.next)e.newEntity(t);return e.nodeList}releaseNodeList(t){this.families.has(t)&&this.families.get(t).cleanUp(),this.families.delete(t)}addSystem(t,e){t.priority=e,t.addToEngine(this),this.systemList.add(t)}getSystem(t){return this.systemList.get(t)}get systems(){const t=[];for(let e=this.systemList.head;e;e=e.next)t[t.length]=e;return t}removeSystem(t){this.systemList.remove(t),t.removeFromEngine(this)}removeAllSystems(){for(;this.systemList.head;){const t=this.systemList.head;this.systemList.head=this.systemList.head.next,t.previous=null,t.next=null,t.removeFromEngine(this)}this.systemList.tail=null}update(t){this.updating=!0;for(let e=this.systemList.head;e;e=e.next)e.update(t);this.updating=!1,this.updateComplete.dispatch()}}class Entity{constructor(t=""){this.previous=null,this.next=null,this.componentAdded=new Signal2,this.componentRemoved=new Signal2,this.nameChanged=new Signal2,this.components=new Map,t?this.pName=t:(Entity.nameCount+=1,this.pName="_entity"+Entity.nameCount)}get name(){return this.pName}set name(t){if(this.pName!==t){const e=this.pName;this.pName=t,this.nameChanged.dispatch(this,e)}}add(t,e=null){return e||(e=t.constructor.prototype.constructor),e=e,this.components.has(e)&&this.remove(e),this.components.set(e,t),this.componentAdded.dispatch(this,e),this}remove(t){const e=this.components.get(t);return e?(this.components.delete(t),this.componentRemoved.dispatch(this,t),e):null}get(t){return this.components.get(t)}getAll(){const t=[];for(const e of this.components.values())t[t.length]=e;return t}has(t){return this.components.has(t)}}Entity.nameCount=0;class Node{constructor(){this.entity=null,this.previous=null,this.next=null}}class System{constructor(){this.previous=null,this.next=null,this.priority=0}}class ComponentInstanceProvider{constructor(t){this.instance=t}getComponent(){return this.instance}get identifier(){return this.instance}}class ComponentSingletonProvider{constructor(t){this.componentType=t}getComponent(){return this.instance||(this.instance=new this.componentType),this.instance}get identifier(){return this.getComponent()}}class ComponentTypeProvider{constructor(t){this.componentType=t}getComponent(){return new this.componentType}get identifier(){return this.componentType}}class DynamicComponentProvider{constructor(t){this.closure=t}getComponent(){return this.closure()}get identifier(){return this.closure}}class StateComponentMapping{constructor(t,e){this.creatingState=t,this.componentType=e,this.withType(e)}withInstance(t){return this.setProvider(new ComponentInstanceProvider(t)),this}withType(t){return this.setProvider(new ComponentTypeProvider(t)),this}withSingleton(t){return t||(t=this.componentType),this.setProvider(new ComponentSingletonProvider(t)),this}withMethod(t){return this.setProvider(new DynamicComponentProvider(t)),this}withProvider(t){return this.setProvider(t),this}add(t){return this.creatingState.add(t)}setProvider(t){this.provider=t,this.creatingState.providers.set(this.componentType,t)}}class EntityState{constructor(){this.providers=new Map}add(t){return new StateComponentMapping(this,t)}get(t){return this.providers.get(t)||null}has(t){return this.providers.has(t)}}class EntityStateMachine{constructor(t){this.entity=t,this.states={}}addState(t,e){return this.states[t]=e,this}createState(t){const e=new EntityState;return this.states[t]=e,e}changeState(t){let e,i=this.states[t];if(!i)throw new Error(`Entity state ${t} doesn't exist`);if(i!==this.currentState){if(this.currentState){e=new Map;for(const t of i.providers.keys())e.set(t,i.providers.get(t));for(const t of this.currentState.providers.keys()){const i=e.get(t)||null;i&&i.identifier===this.currentState.providers.get(t).identifier?e.delete(t):this.entity.remove(t)}}else e=i.providers;for(const t of e.keys())this.entity.add(e.get(t).getComponent(),t);this.currentState=i}else i=null}}class DynamicSystemProvider{constructor(t){this.systemPriority=0,this.method=t}getSystem(){return this.method()}get identifier(){return this.method}get priority(){return this.systemPriority}set priority(t){this.systemPriority=t}}class StateSystemMapping{constructor(t,e){this.creatingState=t,this.provider=e}withPriority(t){return this.provider.priority=t,this}addInstance(t){return this.creatingState.addInstance(t)}addSingleton(t){return this.creatingState.addSingleton(t)}addMethod(t){return this.creatingState.addMethod(t)}addProvider(t){return this.creatingState.addProvider(t)}}class SystemInstanceProvider{constructor(t){this.systemPriority=0,this.instance=t}getSystem(){return this.instance}get identifier(){return this.instance}get priority(){return this.systemPriority}set priority(t){this.systemPriority=t}}class SystemSingletonProvider{constructor(t){this.systemPriority=0,this.componentType=t}getSystem(){return this.instance||(this.instance=new this.componentType),this.instance}get identifier(){return this.getSystem()}get priority(){return this.systemPriority}set priority(t){this.systemPriority=t}}class EngineState{constructor(){this.providers=[]}addInstance(t){return this.addProvider(new SystemInstanceProvider(t))}addSingleton(t){return this.addProvider(new SystemSingletonProvider(t))}addMethod(t){return this.addProvider(new DynamicSystemProvider(t))}addProvider(t){const e=new StateSystemMapping(this,t);return this.providers[this.providers.length]=t,e}}class EngineStateMachine{constructor(t){this.engine=t,this.states={}}addState(t,e){return this.states[t]=e,this}createState(t){const e=new EngineState;return this.states[t]=e,e}changeState(t){let e=this.states[t];if(!e)throw new Error(`Engine state ${t} doesn't exist`);if(e===this.currentState)return void(e=null);const i=[];let s;for(const t of e.providers)i[s=t.identifier]=t;if(this.currentState)for(const t of this.currentState.providers){i[s=t.identifier]?delete i[s]:this.engine.removeSystem(t.getSystem())}for(const t of i)this.engine.addSystem(t.getSystem(),t.priority);this.currentState=e}}class RAFTickProvider extends Signal1{constructor(){super(...arguments),this.rafId=0,this.previousTime=0,this.update=(()=>{this.rafId=window.requestAnimationFrame(this.update);const t=Date.now();this.dispatch((t-this.previousTime)/1e3),this.previousTime=t})}start(){this.previousTime=Date.now(),this.rafId=window.requestAnimationFrame(this.update)}stop(){window.cancelAnimationFrame(this.rafId),this.rafId=0}get playing(){return!!this.rafId}}class IntervalTickProvider extends Signal1{constructor(t){super(),this.intervalId=0,this.previousTime=0,this.pInterval=33,this.update=(()=>{const t=Date.now();this.dispatch((t-this.previousTime)/1e3),this.previousTime=t}),t&&(this.pInterval=t)}start(){this.previousTime=Date.now(),this.intervalId=window.setInterval(this.update,this.pInterval)}stop(){window.clearInterval(this.intervalId),this.intervalId=0}set interval(t){this.pInterval=t,0!==this.intervalId&&(window.clearInterval(this.intervalId),this.intervalId=window.setInterval(this.update,t))}get inteval(){return this.pInterval}get playing(){return!!this.intervalId}}class ComponentPool{static getPool(t){if(ComponentPool.pools.has(t))return ComponentPool.pools.get(t);const e=[];return ComponentPool.pools.set(t,e),e}static get(t){const e=ComponentPool.getPool(t);return e.length>0?e.pop():new t}static dispose(t){if(t){const e=t.constructor.prototype.constructor,i=ComponentPool.getPool(e);i[i.length]=t}}static empty(){ComponentPool.pools=new Map}}ComponentPool.pools=new Map;class ListIteratingSystem extends System{constructor(t){super(),this.nodeList=null,this.nodeClass=t}addToEngine(t){if(this.nodeList=t.getNodeList(this.nodeClass),this.nodeAdded){for(let t=this.nodeList.head;t;t=t.next)this.nodeAdded(t);this.nodeList.nodeAdded.add(this.nodeAdded)}this.nodeRemoved&&this.nodeList.nodeRemoved.add(this.nodeRemoved)}removeFromEngine(t){this.nodeAdded&&this.nodeList.nodeAdded.remove(this.nodeAdded),this.nodeRemoved&&this.nodeList.nodeRemoved.remove(this.nodeRemoved),this.nodeList=null}update(t){for(let e=this.nodeList.head;e;e=e.next)this.updateNode(e,t)}}export{Signal0,Signal1,Signal2,Signal3,ComponentMatchingFamily,keep,Engine,Entity,Node,NodeList,NodePool,System,EntityStateMachine,EngineStateMachine,RAFTickProvider,IntervalTickProvider,ComponentPool,ListIteratingSystem};
